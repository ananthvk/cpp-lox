// This is a small utility that reads a compiled lox program, and updates the CRC header field based
// on the contents of the rest of the file Note: It only checks the magic bytes, and does not
// perform any other checks This can be useful when a developer wants to edit the generated bytecode
// using a hexeditor
// It also operates on the file in-place

#include "crc32.hpp"
#include "datapacker.hpp"
#include "file_header.hpp"
#include <fmt/color.h>
#include <fmt/format.h>
#include <fstream>
#include <iostream>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        fmt::print(fmt::fg(fmt::color::red), "Usage: {} <compiled_lox_file>\n", argv[0]);
        return 1;
    }

    try
    {
        std::fstream file(argv[1], std::ios::binary | std::ios::in | std::ios::out | std::ios::ate);
        if (!file.is_open())
        {
            throw std::system_error(errno, std::generic_category(),
                                    "failed to open bytecode file: " + std::string(argv[1]));
        }

        auto size = file.tellg();
        if (size == -1)
        {
            throw std::logic_error("failed to get file size");
        }

        if (!file.seekg(0, std::ios::beg))
        {
            throw std::logic_error("failed to seek to beginning of file");
        }

        std::vector<uint8_t> buffer(size);
        if (!file.read(reinterpret_cast<char *>(buffer.data()), size))
        {
            throw std::logic_error("failed to read from bytecode file");
        }

        if (buffer.size() < 32)
        {
            throw std::runtime_error("bytecode file is corrupt, < 32 bytes");
        }

        if (buffer[0] != FileHeader::MAGIC[0] || buffer[1] != FileHeader::MAGIC[1] ||
            buffer[2] != FileHeader::MAGIC[2] || buffer[3] != FileHeader::MAGIC[3])
        {
            throw std::runtime_error("Not a valid Lox compiled program");
        }

        uint32_t computed_crc = Crc32_ComputeBuf(0, buffer.data() + 8, buffer.size() - 8);

        // Read the CRC actually in the disk
        uint32_t file_crc = 0;
        datapacker::bytes::decode<datapacker::endian::little>(buffer.data() + 4, file_crc);

        if (computed_crc != file_crc)
        {
            fmt::print("CRC mismatch detected. Updating CRC...\n");

            // Seek to CRC position and write new CRC
            if (!file.seekp(4))
            {
                throw std::logic_error("failed to seek to CRC position");
            }

            uint8_t crc_bytes[4];
            datapacker::bytes::encode<datapacker::endian::little>(crc_bytes, computed_crc);

            if (!file.write(reinterpret_cast<const char *>(crc_bytes), 4))
            {
                throw std::logic_error("failed to write CRC to bytecode file");
            }

            if (!file.flush())
            {
                throw std::logic_error("failed to flush file");
            }

            fmt::print("CRC updated successfully.\n");
        }
        else
        {
            fmt::print("CRC checksum matches what is stored, not doing anything.\n");
        }
    }
    catch (const std::exception &e)
    {
        fmt::print(fmt::fg(fmt::color::red), "Error: {}\n", e.what());
        return 1;
    }

    return 0;
}