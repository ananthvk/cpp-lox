#include "cxxopts.hpp"
#include "lexer.hpp"
#include "lox.hpp"
#include <fmt/color.h>
#include <fmt/format.h>

int main(int argc, char *argv[])
{
    try
    {
        cxxopts::Options options("cpplox", "Lox compiler and interpreter in C++");

        // clang-format off
    options.add_options()
        ("print-tokens",     "Show all tokens generated by the lexer" 
                             " along with line position",
                             cxxopts::value<bool>()->default_value("false"))

        ("compile-only",     "Compiles the source code to bytecode but does not execute it",
                             cxxopts::value<bool>()->default_value("false"))

        ("dump-bytecode",    "Dumps the bytecode generated by the compiler before execution",
                             cxxopts::value<bool>()->default_value("false"))

        ("trace-execution",  "Used for debugging: Prints the bytecode instruction before executing it",
                             cxxopts::value<bool>()->default_value("false"))

        ("trace-eval-stack", "Used for debugginig: Prints the internal evaluation stack before the instruction is executed",
                             cxxopts::value<bool>()->default_value("false"))

        ("enable-step-mode", "Used for debugging: Enables step mode and waits for input before an instruction is executed",
                             cxxopts::value<bool>()->default_value("false"))

        ("eval-stack-size",  "Maximum evaluation stack size allowed",
                             cxxopts::value<int>()->default_value("1024"))

        ("log-gc",           "Logs events that occur during a GC collection",
                             cxxopts::value<bool>()->default_value("false"))

        ("display-mem-stats","Display memory stats, such as number of objects allocated, bytes allocated, etc on program exit",
                             cxxopts::value<bool>()->default_value("false"))

        ("stress-gc",        "Stresses the GC by triggering a collection everytime a new object is created",
                             cxxopts::value<bool>()->default_value("false"))
        
        ("c,command",        "Execute the given command and exit",
                             cxxopts::value<std::string>())

        ("script",           "The lox program file to execute",
                             cxxopts::value<std::string>())

        ("h,help",           "Prints this help message")

        ("v,version",        "Prints program version");

        options.parse_positional({"script"});

        // clang-format on
        auto result = options.parse(argc, argv);

        if (result.count("help"))
        {
            fmt::println("{}", options.help());
            exit(0);
        }

        if (result.count("version"))
        {
            fmt::println("v0.0.1");
            exit(0);
        }

        if (!result.unmatched().empty())
        {
            fmt::println("Invalid number of arguments: expected a single argument or none");
            fmt::println("Check out 'cpplox --help' for usage");
        }

        CompilerOpts copts;
        copts.debug_print_tokens = result["print-tokens"].as<bool>();

        VMOpts vopts;
        vopts.debug_step_mode_enabled = result["enable-step-mode"].as<bool>();
        vopts.debug_trace_execution = result["trace-execution"].as<bool>();
        vopts.debug_stress_gc = result["stress-gc"].as<bool>();
        vopts.debug_log_gc = result["log-gc"].as<bool>();
        vopts.debug_trace_value_stack = result["trace-eval-stack"].as<bool>();
        vopts.value_stack_max = result["eval-stack-size"].as<int>();
        vopts.display_mem_stats = result["display-mem-stats"].as<bool>();

        LoxOpts lopts;
        lopts.dump_bytecode = result["dump-bytecode"].as<bool>();
        lopts.compile_only = result["compile-only"].as<bool>();

        Lox lox(copts, vopts, lopts);

        if (result.count("command") != 0)
            return lox.run_source(result["command"].as<std::string>());

        if (result.count("script") == 0)
            return lox.run_repl();

        // Run the given file
        return lox.run_file(result["script"].as<std::string>());
    }
    catch (std::exception &e)
    {

        fmt::print(fmt::fg(fmt::color::red), "Error: {}\n", e.what());
        exit(1);
    }
    return 0;
}