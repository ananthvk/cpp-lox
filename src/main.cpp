#include "cxxopts.hpp"
#include "lexer.hpp"
#include "lox.hpp"
#include <fmt/color.h>
#include <fmt/format.h>

int main(int argc, char *argv[])
{
    try
    {
        cxxopts::Options options("cpplox", "Lox compiler and interpreter in C++");

        // clang-format off
    options.add_options()
        ("print-tokens",     "Show all tokens generated by the lexer" 
                             " along with line position",
                             cxxopts::value<bool>()->default_value("false"))

        ("compile-only",     "Compiles the source code to bytecode but does not execute it",
                             cxxopts::value<bool>()->default_value("false"))

        ("dump-bytecode",    "Dumps the bytecode generated by the compiler before execution",
                             cxxopts::value<bool>()->default_value("false"))

        ("trace-execution",  "Used for debugging: Prints the bytecode instruction before executing it",
                             cxxopts::value<bool>()->default_value("false"))

        ("trace-eval-stack", "Used for debugginig: Prints the internal evaluation stack before the instruction is executed",
                             cxxopts::value<bool>()->default_value("false"))

        ("enable-step-mode", "Used for debugging: Enables step mode and waits for input before an instruction is executed",
                             cxxopts::value<bool>()->default_value("false"))

        ("eval-stack-size",  "Maximum evaluation stack size allowed",
                             cxxopts::value<int>()->default_value("1024"))

        ("gc-initial-collection-threshold",  "Number of bytes after which GC will collect garbage for the first time",
                             cxxopts::value<int>()->default_value("1048576"))

        ("log-gc",           "Logs events that occur during a GC collection",
                             cxxopts::value<bool>()->default_value("false"))

        ("display-mem-stats","Display memory stats, such as number of objects allocated, bytes allocated, etc on program exit",
                             cxxopts::value<bool>()->default_value("false"))

        ("stress-gc",        "Stresses the GC by triggering a collection everytime a new object is created",
                             cxxopts::value<bool>()->default_value("false"))
        
        ("c,command",        "Execute the given command and exit",
                             cxxopts::value<std::string>())

        ("g,emit-debug-info",  "Include debug information in compiled bytecode (line number mappings). Can only be used with -o/--output flag",
                             cxxopts::value<bool>()->default_value("false"))

        ("script",           "The lox program file to execute",
                             cxxopts::value<std::string>())

        ("o,output",         "Compiles the script, generates the bytecode and store it in the specified file. Does not execute the program",
                             cxxopts::value<std::string>())

        ("h,help",           "Prints this help message")

        ("v,version",        "Prints program version");
        options.parse_positional({"script"});

        // clang-format on
        auto result = options.parse(argc, argv);

        if (result.count("help"))
        {
            fmt::println("{}", options.help());
            exit(0);
        }

        if (result.count("version"))
        {
            fmt::println("v0.0.1");
            exit(0);
        }

        if (!result.unmatched().empty())
        {
            fmt::println("Invalid number of arguments: expected a single argument or none");
            fmt::println("Check out 'cpplox --help' for usage");
        }

        if (result.count("output") != 0)
        {
            if (result.count("script") == 0)
            {
                fmt::println("Error: No script file specified when using --output option");
                exit(1);
            }
            // Check if any VM options are specified - error since the emitted bytecode is stored to
            // a file, and is not executed
            if (result.count("enable-step-mode") != 0 || result.count("trace-execution") != 0 ||
                result.count("stress-gc") != 0 || result.count("log-gc") != 0 ||
                result.count("trace-eval-stack") != 0 || result.count("eval-stack-size") != 0 ||
                result.count("display-mem-stats") != 0 ||
                result.count("gc-initial-collection-threshold") != 0)
            {
                fmt::println(
                    "Error: VM options are not allowed when using --output (compile mode)");
                exit(1);
            }
        }
        if (result.count("output") == 0)
        {
            if (result.count("emit-debug-info") != 0)
            {
                fmt::println(
                    "Error: The flag -g/--emit-debug-info can only be used with --output (compile mode)");
                exit(1);
            }
        }

        CompilerOpts copts;
        copts.debug_print_tokens = result["print-tokens"].as<bool>();
        copts.emit_debug_information = result["emit-debug-info"].as<bool>();

        VMOpts vopts;
        vopts.debug_step_mode_enabled = result["enable-step-mode"].as<bool>();
        vopts.debug_trace_execution = result["trace-execution"].as<bool>();
        vopts.debug_stress_gc = result["stress-gc"].as<bool>();
        vopts.debug_log_gc = result["log-gc"].as<bool>();
        vopts.debug_trace_value_stack = result["trace-eval-stack"].as<bool>();
        vopts.value_stack_max = result["eval-stack-size"].as<int>();
        vopts.display_mem_stats = result["display-mem-stats"].as<bool>();
        vopts.gc_next_collection = result["gc-initial-collection-threshold"].as<int>();

        LoxOpts lopts;
        lopts.dump_bytecode = result["dump-bytecode"].as<bool>();
        lopts.compile_only = result["compile-only"].as<bool>();
        Lox lox(copts, vopts, lopts);


        if (result.count("command") != 0)
            return lox.run_source(result["command"].as<std::string>());

        if (result.count("script") == 0)
            return lox.run_repl();

        if (result.count("output") != 0)
        {
            // Compile the file instead
            return lox.compile_file(result["script"].as<std::string>(),
                                    result["output"].as<std::string>());
        }
        // Run the given file
        return lox.run_file(result["script"].as<std::string>());
    }
    catch (std::exception &e)
    {

        fmt::print(fmt::fg(fmt::color::red), "Error: {}\n", e.what());
        exit(1);
    }
    return 0;
}