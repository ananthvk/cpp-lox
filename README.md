# cpp-lox

My implementation of second part of Lox programming language from [Crafting interpreters](https://www.craftinginterpreters.com/contents.html) in C++. This implementation uses a bytecode VM to execute the programs.

## How to run?

Install `meson`, `ninja` and a C++ 20 capable compiler

```
$ meson setup builddir
$ cd builddir
$ ninja -j8
```

If you are on linux, run
```
$ ./src/bin/cpplox
```

On windows, run
```
.\src\bin\cpplox.exe
```

## To run tests

To run tests, you need to have `Python 3`

First install `pytest`, a test automation library used to test programs.

Create a virtual environment
```
$ python -m venv .venv
```

Install dependencies
```
$ pip install -r requirements.txt
```

After building, three binaries are produced

`./builddir/src/bin/cpplox` - Includes a Compiler, VM and a REPL

`./builddir/src/bin/loxvm` - Standalone VM, does not include compiler, used for running compiled lox programs

`./builddir/src/tools/loxdump` - For disassembling compiled lox programs

Run tests
```
$ meson setup builddir -Denable-tests=true
$ cd builddir
$ ninja -j8
$ meson test -v
```

## To run benchmarks

```
$ cd builddir
$ meson test --benchmark --interactive
```


## Development build

Have `Clang` installed along with `asan`. You also need to follow the steps in the above section, `pytest` must be installed and available on the `PATH`

Then run the following command,
```
$ ./development.sh
```

## Help
```
$ cpplox --help
Lox compiler and interpreter in C++
Usage:
  cpplox [OPTION...] positional parameters

      --print-tokens            Show all tokens generated by the lexer 
                                along with line position
      --compile-only            Compiles the source code to bytecode but 
                                does not execute it
      --dump-bytecode           Dumps the bytecode generated by the 
                                compiler before execution
      --trace-execution         Used for debugging: Prints the bytecode 
                                instruction before executing it
      --trace-eval-stack        Used for debugginig: Prints the internal 
                                evaluation stack before the instruction is 
                                executed
      --enable-step-mode        Used for debugging: Enables step mode and 
                                waits for input before an instruction is 
                                executed
      --eval-stack-size arg     Maximum evaluation stack size allowed 
                                (default: 1024)
      --gc-initial-collection-threshold arg
                                Number of bytes after which GC will collect 
                                garbage for the first time (default: 
                                1048576)
      --log-gc                  Logs events that occur during a GC 
                                collection
      --display-mem-stats       Display memory stats, such as number of 
                                objects allocated, bytes allocated, etc on 
                                program exit
      --stress-gc               Stresses the GC by triggering a collection 
                                everytime a new object is created
  -c, --command arg             Execute the given command and exit
  -g, --emit-debug-info         Include debug information in compiled 
                                bytecode (line number mappings). Can only 
                                be used with -o/--output flag
  -o, --output arg              Compiles the script, generates the bytecode 
                                and store it in the specified file. Does 
                                not execute the program
  -h, --help                    Prints this help message
  -v, --version                 Prints program version
```

## Notable Changes from the book & Usage

### Serialization of bytecode to file and execution of it

Supports storing the compiled bytecode in a file, then loading and executing it. See [bytecode file format](documents/bytecode_file_format.md) to learn more about how the compiled program is stored on disk.

To generate a bytecode file, use the `-o/--output` flag, and optionally the `-g/--emit-debug-info` flag to emit the line-bytecode offset mapping.

Example: 

```
$ cpp-lox program.lox -o compiled.loxc
```

or 

```
$ cpp-lox program.lox -o compiled.loxc -g
```
If you also want to include bytecode line positions.

Execute it with,

```
$ cpp-lox compiled.loxc
```

Use `tools/loxdump` to disassemble a compiled lox program

``
$ ./tools/loxdump compiled.loxc
```

### De-duplication of integers

The compiler de-duplicates integers (but not real numbers)

### More constants

Supports 65k constants, and 65k global variables (accessed with 2 byte unsigned index)

### `const` variables

`const` variables

In global scope,
```
If a constant of the same name has already been declared, do not allow
redeclaration with var Example:
>> const x = 32;
>> var x = 50; // Not allowed

>> const x = 80;
>> const x = 90; // Not Allowed

>> var x = 95;
>> var x = 100; // Allowed
```

One difference is that redeclaration with const is not allowed since it helps make the vm simpler, otherwise an extra flag/byte needs to be maintained to identify if it's a const declaration or a var declaration.

### `switch` statement

Supports C-style switch statements with cases and default:

```lox
switch (value) {
    case 1:
        print "one";
        break;
    case 2:
        var foo = "hello";
        print foo;
        break;
    default:
        print "other";
}
```
- Both the selector and the case value can be expressions  
- Each arm of the switch statement defines a local scope, so variables can be declared within it
- There is no break statement, there is no fallthrough
- Cases cannot appear after the default statement

### Local scope redeclaration  

In local scope redeclaration of any form is disallowed

### List of native functions

- `sqrt(value number) double` - Returns the square root of the number
- `exit(status_code int)` - Exits the interpreter with the status code
- `input() string` - Takes a line of input from `stdin`, does not include terminating `\n`
- `print(args...)` - Prints all the arguments, separated by a space
- `println(args...)` - Prints all the arguments, separated by a space, and adds a newline at the end
- `len(str string) int` - Returns the length of the string / list
- `to_string(value) string` - Converts the given value into a string
- `to_int(value) int` - Converts the given value into an int
- `to_double(value) double` - Converts the given value into a double
- `type(value) string` - Returns the type of the value as string
- `rand() double` - Returns a random double between [0, 1) (inclusive of 0, exclusive of 1)
- `randint(m int, n int) int` - Returns a random integer between m & n (inclusive at both ends)
- `assert(value bool, message string)` - Raises a runtime error & prints the message if value is false. Does nothing if value is true
- `sys__mem_get_bytes_allocated() int` - Returns the total number of bytes allocated by the garbage collector
- `sys__mem_get_bytes_freed() int` - Returns the total number of bytes freed by the garbage collector
- `sys__mem_get_next_gc() int` - Returns the threshold in bytes at which the next garbage collection will trigger
- `sys__mem_get_objects_created() int` - Returns the total number of objects created by the garbage collector
- `sys__mem_get_objects_freed() int` - Returns the total number of objects freed by the garbage collector
- `sys__mem_get_live_objects() int` - Returns the current number of live objects managed by the garbage collector
- `sys__mem_get_net_bytes() int` - Returns the net bytes currently allocated (allocated - freed)
- `sys__mem_display_gc_stats()` - Prints detailed garbage collection statistics to the console

### No print statements

`print` statement is renamed to `echo`. This was done to maintain compatability with tests without major refactoring.
Do not use this statement unless needed, and instead use the `print()` and `println()` functions.

Note: The GC implementation in my project does *not* track all memory and it will use a bit of extra memory. This is because some parts of the application uses `std::vector` and `std::string` that are not managed by the garbage collector. In the book, all memory is allocated through `reallocate()` hence the GC has complete control over the memory. But in my implementation, all vectors & strings are wrapped in VM objects, so once they are freed, the associated vectors & strings get freed too.

### Native functions for accessing properties

Native functions for manipulating and accessing properties (fields)

- `has_property(instance, string) bool` - Returns true if the property exists on the instance (similar to `hasattr` of python)
- `get_property(instance, string) value` - Returns the value of the property on the instance (similar to `getattr` of python)
- `set_property(instance, string, value)` - Sets the property on the instance to the given value (similar to `setattr` of python)
- `del_property(instance, string) bool` - Deletes a property on an instance, returns true if the property was deleted, false if the property did not not exist

### Optional chaining operator `?.`

This operator is similar to the one in JS and can be used to access properties of nested objects easily (when some intermediate object is nil / not an instance)

Example:

```
var result = x?.y?.z?.w;
```
If any of x, y, or z is `nil`, or the property does not exist, or the property is not an instance, the result is `nil`

If the base (`x`) is not defined, the expression results in an error 

```
class Foo {}
var f = Foo();
f.x = print;
println(f.x?.prop); // nil (becasue x is a native function)
```

### `:` instead of `<` for inheritance

For inheritance, instead of `<` operator, I have decided to use `:` in my language (similar to C++)

Example:
```
class Foo {
}
class Bar : Foo {
}
```

### Additional OPCODES for optimization of constants

Three new instructions, `ZERO`, `ONE`, `MINUS_ONE`, that push `0`, `1`, and `-1` respectively on to the stack. This was added as an optimization, so that the value need not be loaded from the constant table whenever these values are present.

### Lists (dynamic arrays)

Implement list data structure (Note: It's implemented as a dynamic array (vector) rather than a linked list (like CPython))

Example:
```
var x = [1, 2, 3]; // Create a list
println(x[0]); // Get element at index, prints 1
println(x); // Print the list
println(x[0] = 8); // Prints 8, sets index 0 to 8
```

Implementation: Two new opcodes `LIST` and `LIST_APPEND` have been added. `LIST` takes a single byte operand, the intial size of the list (`n`), and it reads & pops the top `n` values on stack and creates a new list object. If `n` >= 10, the compiler will emit a `LIST` list instruction to build the list with 10 values, and for the remaining values, it adds a `LIST_APPEND` after emitting the bytecode for the expression. This is done so that the stack does not overflow when a list is declared with a lot of elements.

Note: Allocating huge lists eg (`list(10000000, 0)`) may cause the program to pause because the GC has to trace through all those values even if there are no object references. In the future, try to optimize this

Another two instructions: `LOAD_INDEX` and `STORE_INDEX` to access and modify list members

For `STORE_INDEX`: `[container, index, value] -> [ ] after execution`
For `LOAD_INDEX`: `[container, index] -> [value]`

Native functions to work with lists
- `len(list) int`: Returns the length of the list, works the same with strings
- `cap(list) int`: Returns the capacity of the backing array of the list
- `list(len, default, cap) list`: Creates a new list with the specified length, capacity, and default value. All three arguments are optional. len is the initial length of the list, cap is the capacity of the list (after which a new reallocation will be triggered), and default is the default value when creating the list (default is nil).
- `append(list, element)`: Adds an element to the end of a list
- `delete(list, index)`: Removes an element at specified index from list
- `pop(list) value`: Removes and returns the last element from a list

### String indexing

Indexing works with strings too

The result of indexing a string results in another string (there is no character datatype)

Example:
```
var x = "hello";
println(x[1]); // prints e

x[2] = "x"; // Not allowed, throws error since strings are immutable
```

## Documents

[Opcodes list](documents/opcodes_list.md)

[Bytecode file format](documents/bytecode_file_format.md)

## TODO
- [ ] Fix division by zero error
- [ ] Implement break statements
- [ ] Implement slices