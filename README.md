# cpp-lox

My implementation of second part of Lox programming language from [Crafting interpreters](https://www.craftinginterpreters.com/contents.html) in C++. This implementation uses a bytecode VM to execute the programs.

## How to run?

Install `meson`, `ninja` and a C++ 20 capable compiler

```
$ meson setup builddir
$ cd builddir
$ ninja -j8
```

If you are on linux, run
```
$ ./src/cpplox
```

On windows, run
```
.\src\cpplox.exe
```

## To run tests

To run tests, you need to have `Python 3`

First install `pytest`, a test automation library used to test programs.

Create a virtual environment
```
$ python -m venv .venv
```

Install dependencies
```
$ pip install -r requirements.txt
```

Run tests
```
$ meson setup builddir -Denable-tests=true
$ cd builddir
$ ninja -j8
$ meson test -v
```

## Development build

Have `Clang` installed along with `asan`. You also need to follow the steps in the above section, `pytest` must be installed and available on the `PATH`

Then run the following command,
```
$ ./development.sh
```

## Help
```
$ cpplox --help
Lox compiler and interpreter in C++
Usage:
  cpplox [OPTION...] positional parameters

      --print-tokens         Show all tokens generated by the lexer along 
                             with line position
      --compile-only         Compiles the source code to bytecode but does 
                             not execute it
      --dump-bytecode        Dumps the bytecode generated by the compiler 
                             before execution
      --trace-execution      Used for debugging: Prints the bytecode 
                             instruction before executing it
      --trace-eval-stack     Used for debugginig: Prints the internal 
                             evaluation stack before the instruction is 
                             executed
      --enable-step-mode     Used for debugging: Enables step mode and 
                             waits for input before an instruction is 
                             executed
      --eval-stack-size arg  Maximum evaluation stack size allowed 
                             (default: 1024)
  -c, --command arg          Execute the given command and exit
  -h, --help                 Prints this help message
  -v, --version              Prints program version
```

## Changes from the book

1) The compiler de-duplicates both strings and integers (but not real numbers)

2) Supports 65k constants, and 65k global variables (accessed with 2 byte unsigned index)

3) `const` variables

In global scope,
```
If a constant of the same name has already been declared, do not allow
redeclaration with var Example:
>> const x = 32;
>> var x = 50; // Not allowed

>> const x = 80;
>> const x = 90; // Not Allowed

>> var x = 95;
>> var x = 100; // Allowed
```

One difference is that redeclaration with const is not allowed since it helps make the vm simpler, otherwise an extra flag/byte needs to be maintained to identify if it's a const declaration or a var declaration.

4) `switch` statement

Supports C-style switch statements with cases and default:

```lox
switch (value) {
    case 1:
        print "one";
        break;
    case 2:
        var foo = "hello";
        print foo;
        break;
    default:
        print "other";
}
```
- Both the selector and the case value can be expressions  
- Each arm of the switch statement defines a local scope, so variables can be declared within it
- There is no break statement, there is no fallthrough
- Cases cannot appear after the default statement

5) 

In local scope redeclaration of any form is disallowed

6) Other native functions

- `sqrt(value number) double` - Returns the square root of the number
- `exit(status_code int)` - Exits the interpreter with the status code
- `input() string` - Takes a line of input from `stdin`, does not include terminating `\n`
- `print(args...)` - Prints all the arguments, separated by a space
- `println(args...)` - Prints all the arguments, separated by a space, and adds a newline at the end
- `len(str string) int` - Returns the length of the string
- `to_string(value) string` - Converts the given value into a string
- `to_int(value) int` - Converts the given value into an int
- `to_double(value) double` - Converts the given value into a double
- `type(value) string` - Returns the type of the value as string
- `rand() double` - Returns a random double between [0, 1) (inclusive of 0, exclusive of 1)
- `randint(m int, n int) int` - Returns a random integer between m & n (inclusive at both ends)
- `assert(value bool, message string)` - Raises a runtime error & prints the message if value is false. Does nothing if value is true
- `sys__mem_get_bytes_allocated() int` - Returns the total number of bytes allocated by the garbage collector
- `sys__mem_get_bytes_freed() int` - Returns the total number of bytes freed by the garbage collector
- `sys__mem_get_next_gc() int` - Returns the threshold in bytes at which the next garbage collection will trigger
- `sys__mem_get_objects_created() int` - Returns the total number of objects created by the garbage collector
- `sys__mem_get_objects_freed() int` - Returns the total number of objects freed by the garbage collector
- `sys__mem_get_live_objects() int` - Returns the current number of live objects managed by the garbage collector
- `sys__mem_get_net_bytes() int` - Returns the net bytes currently allocated (allocated - freed)
- `sys__mem_display_gc_stats()` - Prints detailed garbage collection statistics to the console

7) `print` statement is renamed to `echo`. This was done to maintain compatability with tests without major refactoring.
Do not use this statement unless needed, and instead use the `print()` and `println()` functions.

Note: The GC implementation in my project does *not* track all memory and it will use a bit of extra memory. This is because some parts of the application uses `std::vector` and `std::string` that are not managed by the garbage collector. In the book, all memory is allocated through `reallocate()` hence the GC has complete control over the memory. But in my implementation, all vectors & strings are wrapped in VM objects, so once they are freed, the associated vectors & strings get freed too.

8) Native functions for manipulating and accessing properties (fields)

- `has_property(instance, string) bool` - Returns true if the property exists on the instance (similar to `hasattr` of python)
- `get_property(instance, string) value` - Returns the value of the property on the instance (similar to `getattr` of python)
- `set_property(instance, string, value)` - Sets the property on the instance to the given value (similar to `setattr` of python)
- `del_property(instance, string) bool` - Deletes a property on an instance, returns true if the property was deleted, false if the property did not not exist

## TODO
- [ ] Fix division by zero error
- [ ] Implement break statements
